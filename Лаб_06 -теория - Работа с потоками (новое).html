<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=Generator content="Microsoft Word 15 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:0cm;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri",sans-serif;}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:36.0pt;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri",sans-serif;}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri",sans-serif;}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri",sans-serif;}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:36.0pt;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri",sans-serif;}
.MsoChpDefault
	{font-family:"Calibri",sans-serif;}
.MsoPapDefault
	{margin-bottom:8.0pt;
	line-height:107%;}
@page WordSection1
	{size:595.3pt 841.9pt;
	margin:2.0cm 42.5pt 2.0cm 3.0cm;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=RU>

<div class=WordSection1>

<p class=MsoNormal align=center style='text-align:center'><b>Потоки и система
ввода-вывода</b></p>

<p class=MsoNormal style='text-indent:35.45pt'><b>Базовые типы для работы с
потоками</b></p>

<p class=MsoNormal style='text-indent:35.45pt'>Все инструменты для работы с
системой ввода-вывода и потоками в языке С++ определены в стандартной
библиотеке. Заголовочный файл iostream определяет следующие базовые типы для
работы с потоками:</p>

<p class=MsoNormal>    istream и wistream: читают данные с потока</p>

<p class=MsoNormal>    ostream и wostream: записывают данные в поток</p>

<p class=MsoNormal>    iostream и wiostream: читают и записывают данные в поток</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Для каждого
типа определен его двойник, который начинается на букву w и который
предназначен для поддержки данных типа wchar_t.</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Эти типы
являются базовыми для других классов, управляющих потоками ввода-вывода.</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Объект типа
ostream получает значения различных типов, преобразует их в последовательность
символов и передает их через буфер в определенное место для вывода (консоль,
файл, сетевые интерфейсы и т.д.)</p>

<p class=MsoNormal><span lang=EN-US><img width=623 height=102 id="Рисунок 1"
src="Лаб_06%20-теория%20-%20Работа%20с%20потоками%20(новое).files/image001.png"></span></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Поток istream
получает через буфер из определенного места последовательности символов (с
консоли, из файла, из сети и т.д.) и преобразует эти последовательности в
значения различных типов. То есть когда мы вводим данные (с той же клавиатуры в
консоли), сначала данные накапливаются в буфере и только затем передаются
объекту istream.</p>

<p class=MsoNormal style='text-align:justify'><img width=624 height=107
id="Рисунок 2"
src="Лаб_06%20-теория%20-%20Работа%20с%20потоками%20(новое).files/image002.png"></p>

<p class=MsoNormal style='text-align:justify'>По умолчанию в стандартной
библиотеке определены объекты этих классов - cout, cin, cerr, которые работают
с консолью.</p>

<p class=MsoNormal style='text-align:justify'><b>Запись в поток</b></p>

<p class=MsoNormal style='text-align:justify'>&nbsp;</p>

<p class=MsoNormal>Для записи данных в поток ostream применяется оператор
&lt;&lt;. Этот оператор получает два операнда. Левый операнд представляет
объект типа ostream, а правый операнд - значение, которое надо вывести в поток.</p>

<p class=MsoNormal>К примеру, по умолчанию стандартная библиотека C++
предоставляет объект cout, который представляет тип ostream и позволяет
выводить данные на консоль:</p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>#include &lt;iostream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US> int main()</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cout &lt;&lt; &quot;Hello&quot;
&lt;&lt; std::endl;</span></p>

<p class=MsoNormal>}</p>

<p class=MsoNormal style='text-indent:35.45pt'>Так как оператор &lt;&lt;
возвращает левый операнд - cout, то с помощью цепочки операторов мы можем
передать на консоль несколько значений:</p>

<p class=MsoNormal><span lang=EN-US>std::cout &lt;&lt; &quot;Hello&quot;
&lt;&lt; &quot; world&quot; &lt;&lt; std::endl;</span></p>

<p class=MsoNormal style='text-indent:35.45pt'><b>Чтение данных</b></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Для чтения
данных из потока применяется оператор ввода &gt;&gt;, который принимает два
операнда. Левый операнд представляет поток istream, с которого производится
считывание, а правый операнд - объект, в который считываются данные.</p>

<p class=MsoNormal style='text-indent:35.45pt'>Для чтения с консоли применяется
объект cin, который представляет тип istream.</p>

<p class=MsoNormal><span lang=EN-US>#include &lt;iostream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US> int main()</span></p>

<p class=MsoNormal><span lang=EN-US>{   </span></p>

<p class=MsoNormal><span lang=EN-US>    int age;</span></p>

<p class=MsoNormal><span lang=EN-US>    double weight;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cout &lt;&lt; &quot;Input age:
&quot;;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cin &gt;&gt; age;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cout &lt;&lt; &quot;Input weight:
&quot;;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cin &gt;&gt; weight;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cout &lt;&lt; &quot;Your age:
&quot; &lt;&lt; age &lt;&lt; &quot;\t your weight: &quot; &lt;&lt; weight
&lt;&lt; std::endl;</span></p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Однако такой
способ не очень подходит для чтения строк с консоли особенно когда считываемая
строка содержит пробельные символы. В этом случае лучше использовать встроенную
функцию getline(), которая в качестве параметра принимает поток istream и
переменную типа string, в которую надо считать данные:</p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>#include &lt;iostream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>int main()</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    std::string name;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cout &lt;&lt; &quot;Input name:
&quot;;</span></p>

<p class=MsoNormal><span lang=EN-US>    getline(std::cin, name);</span></p>

<p class=MsoNormal><span lang=EN-US>    //std::cin &gt;&gt; name;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cout &lt;&lt; &quot;Your name:
&quot; &lt;&lt; name &lt;&lt;std::endl;</span></p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Пример работы программы:</p>

<p class=MsoNormal>Input name: Tom Smit</p>

<p class=MsoNormal>Your name: Tom Smit</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>По умолчанию
признаком окончания ввода служит перевод на другую строку, например, с помощью
клавиши Enter. Но также можно задать свой признак окончания ввода с помощью
дополнительного параметра функции getline(). Для этого надо передать символ,
который будет служить окончанием ввода:</p>

<p class=MsoNormal><span lang=EN-US>#include &lt;iostream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>int main()</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    std::string text;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cout &lt;&lt; &quot;Input text:
&quot; &lt;&lt; std::endl;</span></p>

<p class=MsoNormal><span lang=EN-US>    </span>getline(std::cin, text, '*');  
// окончанием ввода будет служить символ *</p>

<p class=MsoNormal>    <span lang=EN-US>std::cout &lt;&lt; &quot;\nYour
text:&quot; &lt;&lt;std::endl;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cout &lt;&lt; text
&lt;&lt;std::endl;</span></p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>В данном
случае ввод завершится, когда пользователь введет символ *. Таким образом, мы
можем ввести многострочный текст, но при вводе звездочки ввод завершится. </p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Пример работы
программы:</p>

<p class=MsoNormal><span lang=EN-US>Input</span><span lang=EN-US> </span><span
lang=EN-US>text</span>:</p>

<p class=MsoNormal><span lang=EN-US>Hello World</span></p>

<p class=MsoNormal><span lang=EN-US>Good bye world*</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>Your text:</span></p>

<p class=MsoNormal><span lang=EN-US>Hello World</span></p>

<p class=MsoNormal><span lang=EN-US>Good bye world</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:35.45pt'><b>Вывод ошибок</b></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Для вывода
сообщения об ошибке на консоль применяется объект cerr, который представляет
объект типа ostream:</p>

<p class=MsoNormal>#include &lt;iostream&gt;</p>

<p class=MsoNormal><span lang=EN-US>int main()</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    std::cerr &lt;&lt; &quot;Error
occured&quot; &lt;&lt; std::endl;</span></p>

<p class=MsoNormal><span lang=EN-US>}</span></p>

<p class=MsoNormal style='text-indent:35.45pt'><b>Потоки</b><b> символов</b><b><span
lang=EN-US> wchar_t</span></b></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Для работы с потоками
данных типов <span lang=EN-US>wchar</span>_<span lang=EN-US>t</span><span
lang=EN-US> </span>в стандартной библиотеке определены объекты <span
lang=EN-US>wcout</span> (тип <span lang=EN-US>wostream</span>), <span
lang=EN-US>wcerr</span> (тип <span lang=EN-US>wostream</span>) и <span
lang=EN-US>wcin</span> (тип <span lang=EN-US>wistream</span>), которые являются
аналогами для объектов <span lang=EN-US>cout</span>, <span lang=EN-US>cerr</span><span
lang=EN-US> </span>и <span lang=EN-US>cin</span><span lang=EN-US> </span>и работают
аналогично</p>

<p class=MsoNormal>#include &lt;iostream&gt;</p>

<p class=MsoNormal><span lang=EN-US>int main()</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    int age;</span></p>

<p class=MsoNormal><span lang=EN-US>    double weight;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::wcout &lt;&lt; &quot;Input age:
&quot;;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::wcin &gt;&gt; age;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::wcout &lt;&lt; &quot;Input weight:
&quot;;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::wcin &gt;&gt; weight;</span></p>

<p class=MsoNormal><span lang=EN-US>    if (age &lt;= 0 || weight &lt;= 0)</span></p>

<p class=MsoNormal><span lang=EN-US>        std::wcerr &lt;&lt; &quot;Invalid
data&quot; &lt;&lt; std::endl;</span></p>

<p class=MsoNormal><span lang=EN-US>    else</span></p>

<p class=MsoNormal><span lang=EN-US>        std::wcout &lt;&lt; &quot;Your age:
&quot; &lt;&lt; age &lt;&lt; &quot;\t your weight: &quot; &lt;&lt; weight
&lt;&lt; std::endl;</span></p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal align=center style='text-align:center'><b>Файловые потоки.
Открытие и закрытие</b></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Для работы с
файлами в стандартной библиотеке определен заголовочный файл fstream, который
определяет базовые типы для чтения и записи файлов. В частности, это:</p>

<p class=MsoNormal>    ifstream: для чтения с файла</p>

<p class=MsoNormal>    ofstream: для записи в файл</p>

<p class=MsoNormal>    fstream: совмещает запись и чтение</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-indent:35.45pt'>Для работы с данными типа
wchar_t для этих потоков определены двойники:</p>

<p class=MsoNormal>    wifstream</p>

<p class=MsoNormal>    wofstream</p>

<p class=MsoNormal>    wfstream</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-indent:35.45pt'><b>Открытие файла</b></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>При операциях
с файлом вначале необходимо открыть файл с помощью функции open(). Данная
функция имеет две версии:</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal align=center style='text-align:center'>open(путь)</p>

<p class=MsoNormal align=center style='text-align:center'>&nbsp;</p>

<p class=MsoNormal align=center style='text-align:center'>open(путь, режим)</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Для открытия
файла в функцию необходимо передать путь к файлу в виде строки. И также можно
указать режим открытия. Список доступных режимов открытия файла:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:14.2pt;text-align:justify;
text-indent:-14.2pt'><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>ios::in: файл открывается для ввода (чтения). Может быть
установлен только для объекта ifstream или fstream</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:14.2pt;text-align:justify;
text-indent:-14.2pt'><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>ios::out: файл открывается для вывода (записи). При этом старые
данные удаляются. Может быть установлен только для объекта ofstream или fstream</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:14.2pt;text-align:justify;
text-indent:-14.2pt'><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>ios::app: файл открывается для дозаписи. Старые данные не
удаляются.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:14.2pt;text-align:justify;
text-indent:-14.2pt'><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>ios::ate: после открытия файла перемещает указатель в конец файла</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:14.2pt;text-align:justify;
text-indent:-14.2pt'><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>ios::trunc: файл усекается при открытии. Может быть установлен,
если также установлен режим out</p>

<p class=MsoListParagraphCxSpLast style='margin-left:14.2pt;text-align:justify;
text-indent:-14.2pt'><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>ios::binary: файл открывается в бинарном режиме</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Если при
открытии режим не указан, то по умолчанию для объектов ofstream применяется
режим ios::out, а для объектов ifstream - режим ios::in. Для объектов fstream
совмещаются режимы ios::out и ios::in.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>std::ofstream out;           // поток для записи</p>

<p class=MsoNormal>out.open(&quot;hello1.txt&quot;); // окрываем файл для
записи</p>

<p class=MsoNormal>               </p>

<p class=MsoNormal><span lang=EN-US>std::ofstream out2;</span></p>

<p class=MsoNormal><span lang=EN-US>out2.open(&quot;hello2.txt&quot;,
std::ios::app); // </span>окрываем файл для дозаписи</p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>std::ofstream out3;</span></p>

<p class=MsoNormal><span lang=EN-US>out2.open(&quot;hello3.txt&quot;,
std::ios::out | std::ios::trunc); // </span>установка нескольких режимов</p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal>std::ifstream in;                              // поток для
чтения</p>

<p class=MsoNormal>in.open(&quot;hello4.txt&quot;);    // открываем файл для
чтения</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>std::fstream fs;                // поток для чтения-записи</p>

<p class=MsoNormal>fs.open(&quot;hello5.txt&quot;);    // открываем файл для
чтения-записи</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Однако в
принципе необязательно использовать функцию open для открытия файла. В качестве
альтернативы можно также использовать конструктор объектов-потоков и передавать
в них путь к файлу и режим открытия:</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal align=center style='text-align:center'>fstream(путь)</p>

<p class=MsoNormal align=center style='text-align:center'>fstream(путь, режим)</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>При вызове
конструктора, в который передан путь к файлу, данный файл будет автоматически
открываться:</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><span lang=EN-US>std::ofstream out(&quot;hello.txt&quot;);</span></p>

<p class=MsoNormal><span lang=EN-US>std::ifstream in(&quot;hello.txt&quot;);</span></p>

<p class=MsoNormal><span lang=EN-US>std::fstream fs(&quot;hello.txt&quot;,
std::ios::app);</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>В данном
случае предполагается, что файл &quot;hello.txt&quot; располагается в той же
папке, где и файл программы.</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Вообще
использование конструкторов для открытия потока является более
предпочтительным, так как определение переменной, представляющей файловой
поток, уже преполагает, что этот поток будет открыт для чтения или записи. А
использование конструктора избавит от ситуации, когда мы забудем открыть поток,
но при этом начнем его использовать.</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>В процессе
работы мы можем проверить, окрыт ли файл с помощью функции is_open(). Если файл
открыт, то она возвращает true:</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>std::ifstream in;                              // поток для
чтения</p>

<p class=MsoNormal>in.open(&quot;hello.txt&quot;); // открываем файл для чтения</p>

<p class=MsoNormal>// если файл открыт</p>

<p class=MsoNormal>if (in.is_open())</p>

<p class=MsoNormal>{</p>

<p class=MsoNormal>…</p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-indent:35.45pt'><b>Закрытие файла</b></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>После
завершения работы с файлом его следует закрыть с помощью функции close(). Также
стоит отметить, то при выходе объекта потока из области видимости, он
удаляется, и у него автоматически вызывается функция close.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><span lang=EN-US>#include &lt;iostream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>#include &lt;fstream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>int main()</span></p>

<p class=MsoNormal>{</p>

<p class=MsoNormal>               std::ofstream out;           // поток для
записи</p>

<p class=MsoNormal>               out.open(&quot;hello.txt&quot;);   //
открываем файл для записи</p>

<p class=MsoNormal>               out.close();                        //
закрываем файл</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>               std::ifstream in;                              //
поток для чтения</p>

<p class=MsoNormal>               in.open(&quot;hello.txt&quot;);      //
открываем файл для чтения</p>

<p class=MsoNormal>               in.close();                           //
закрываем файл</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>               std::fstream fs;                // поток для
чтения-записи</p>

<p class=MsoNormal>               fs.open(&quot;hello.txt&quot;);       //
открываем файл для чтения-записи</p>

<p class=MsoNormal>               fs.close();                           //
закрываем файл</p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal align=center style='text-align:center'><b>Чтение и запись
текстовых файлов</b></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Потоки для работы
с текстовыми файлами представляют объекты, для которых не задан режим открытия
ios::binary.</p>

<p class=MsoNormal style='text-indent:35.45pt'><b>Запись в файл</b></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Для записи в
файл к объекту ofstream или fstream применяется оператор &lt;&lt; (как и при
выводе на консоль):</p>

<p class=MsoNormal><span lang=EN-US>#include &lt;iostream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>#include &lt;fstream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US> </span></p>

<p class=MsoNormal><span lang=EN-US>int main()</span></p>

<p class=MsoNormal>{</p>

<p class=MsoNormal>    std::ofstream out;          // поток для записи</p>

<p class=MsoNormal>    out.open(&quot;hello.txt&quot;);      // открываем файл
для записи</p>

<p class=MsoNormal>    <span lang=EN-US>if (out.is_open())</span></p>

<p class=MsoNormal><span lang=EN-US>    {</span></p>

<p class=MsoNormal><span lang=EN-US>        out &lt;&lt; &quot;Hello
World!&quot; &lt;&lt; std::endl;</span></p>

<p class=MsoNormal><span lang=EN-US>    }</span></p>

<p class=MsoNormal><span lang=EN-US>    out.close(); </span></p>

<p class=MsoNormal><span lang=EN-US>    std::cout &lt;&lt; &quot;File has been
written&quot; &lt;&lt; std::endl;</span></p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Здесь
предполагается, что файла &quot;hello.txt&quot; располагается в одной папке с
файлом программы. Данный способ перезаписывает файл заново. Если надо
дозаписать текст в конец файла, то для открытия файла нужно использовать режим
ios::app:</p>

<p class=MsoNormal><span lang=EN-US>std::ofstream out(&quot;hello.txt&quot;,
std::ios::app);</span></p>

<p class=MsoNormal><span lang=EN-US>if (out.is_open())</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    out &lt;&lt; &quot;Welcome to C++&quot;
&lt;&lt; std::endl;</span></p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>out.close();        </p>

<p class=MsoNormal style='text-indent:35.45pt'><b>&nbsp;</b></p>

<p class=MsoNormal style='text-indent:35.45pt'><b>Чтение из файла</b></p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Если надо
считать всю строку целиком или даже все строки из файла, то лучше использовать
встроенную функцию getline(), которая принимает поток для чтения и переменную,
в которую надо считать текст:</p>

<p class=MsoNormal><span lang=EN-US>#include &lt;iostream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>#include &lt;fstream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>#include &lt;string&gt;     // </span>для<span
lang=EN-US> std::getline</span></p>

<p class=MsoNormal><span lang=EN-US>int main()</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    std::string line;</span></p>

<p class=MsoNormal><span lang=EN-US> </span></p>

<p class=MsoNormal><span lang=EN-US>    std::ifstream
in(&quot;hello.txt&quot;); // </span>окрываем файл для чтения</p>

<p class=MsoNormal><span lang=EN-US>    if (in.is_open())</span></p>

<p class=MsoNormal><span lang=EN-US>    {</span></p>

<p class=MsoNormal><span lang=EN-US>        while (std::getline(in, line))</span></p>

<p class=MsoNormal><span lang=EN-US>        {</span></p>

<p class=MsoNormal><span lang=EN-US>            std::cout &lt;&lt; line
&lt;&lt; std::endl;</span></p>

<p class=MsoNormal><span lang=EN-US>        </span>}</p>

<p class=MsoNormal>    }</p>

<p class=MsoNormal>    in.close();     // закрываем файл</p>

<p class=MsoNormal>}</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Также для
чтения данных из файла для объектов ifstream и fstream может применяться
оператор &gt;&gt; (также как и при чтении с консоли):</p>

<p class=MsoNormal>               </p>

<p class=MsoNormal><span lang=EN-US>#include &lt;iostream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>#include &lt;fstream&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>#include &lt;vector&gt;</span></p>

<p class=MsoNormal><span lang=EN-US>struct Point</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    Point(double x, double y): x{x}, y{y}
{}</span></p>

<p class=MsoNormal><span lang=EN-US>    double x;</span></p>

<p class=MsoNormal><span lang=EN-US>    double y;</span></p>

<p class=MsoNormal><span lang=EN-US>};</span></p>

<p class=MsoNormal><span lang=EN-US>int main()</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    std::vector&lt;Point&gt; points{
Point{0, 0}, Point{4, 5}, Point{-5, 7}};</span></p>

<p class=MsoNormal><span lang=EN-US>      </span></p>

<p class=MsoNormal><span lang=EN-US>    std::ofstream
out(&quot;points.txt&quot;);</span></p>

<p class=MsoNormal><span lang=EN-US>      </span></p>

<p class=MsoNormal><span lang=EN-US>    </span>if (out.is_open())</p>

<p class=MsoNormal>    {</p>

<p class=MsoNormal>        // записываем все объекты Point в файл</p>

<p class=MsoNormal>        <span lang=EN-US>for (const Point&amp; point:
points)</span></p>

<p class=MsoNormal><span lang=EN-US>        {</span></p>

<p class=MsoNormal><span lang=EN-US>            out &lt;&lt; point.x &lt;&lt;
&quot; &quot; &lt;&lt; point.y &lt;&lt; std::endl;</span></p>

<p class=MsoNormal><span lang=EN-US>        }</span></p>

<p class=MsoNormal><span lang=EN-US>    }</span></p>

<p class=MsoNormal><span lang=EN-US>    out.close();</span></p>

<p class=MsoNormal><span lang=EN-US>  </span></p>

<p class=MsoNormal><span lang=EN-US>    std::vector&lt;Point&gt; new_points;</span></p>

<p class=MsoNormal><span lang=EN-US>    std::ifstream in(&quot;points.txt&quot;);
// </span>окрываем файл для чтения</p>

<p class=MsoNormal><span lang=EN-US>    if (in.is_open())</span></p>

<p class=MsoNormal><span lang=EN-US>    {</span></p>

<p class=MsoNormal><span lang=EN-US>        double x, y;</span></p>

<p class=MsoNormal><span lang=EN-US>        while (in &gt;&gt; x &gt;&gt; y)</span></p>

<p class=MsoNormal><span lang=EN-US>        {</span></p>

<p class=MsoNormal><span lang=EN-US>            new_points.push_back(Point{x,
y});</span></p>

<p class=MsoNormal><span lang=EN-US>        }</span></p>

<p class=MsoNormal><span lang=EN-US>    }</span></p>

<p class=MsoNormal><span lang=EN-US>    in.close();</span></p>

<p class=MsoNormal><span lang=EN-US>  </span></p>

<p class=MsoNormal><span lang=EN-US>    for (const Point&amp; point:
new_points)</span></p>

<p class=MsoNormal><span lang=EN-US>    {</span></p>

<p class=MsoNormal><span lang=EN-US>        std::cout &lt;&lt; &quot;Point X:
&quot; &lt;&lt; point.x &lt;&lt; &quot;\tY: &quot; &lt;&lt; point.y &lt;&lt;
std::endl;</span></p>

<p class=MsoNormal><span lang=EN-US>    </span>}</p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Здесь вектор структур Point записывается в файл.</p>

<p class=MsoNormal><span lang=EN-US>for (const Point&amp; point: points)</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    out &lt;&lt; point.x &lt;&lt; &quot;
&quot; &lt;&lt; point.y &lt;&lt; std::endl;</span></p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>При чем при записи значений переменных файл они отделяются
пробелом. В итоге будет создаваться файл в формате</p>

<p class=MsoNormal>0 0</p>

<p class=MsoNormal>4 5</p>

<p class=MsoNormal>-5 7</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Используя оператор &gt;&gt;, можно считать последовательно
данные в переменные x и y и ими инициализировать структуру.</p>

<p class=MsoNormal><span lang=EN-US>double x, y;</span></p>

<p class=MsoNormal><span lang=EN-US>while (in &gt;&gt; x &gt;&gt; y)</span></p>

<p class=MsoNormal><span lang=EN-US>{</span></p>

<p class=MsoNormal><span lang=EN-US>    new_points.push_back(Point{x, y});</span></p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>Но стоит
отметить, что это ограниченный способ, поскольку при чтении файла поток in
использует пробел для отделения одного значения от другого и таким образом
считывает эти значения в переменные x и y. Если же нам надо записать и затем
считать строку, которая содержит пробелы, и какие-то другие данные, то такой
способ, конечно, не сработает.</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>&nbsp;</p>

<p class=MsoNormal style='text-align:justify;text-indent:35.45pt'>&nbsp;</p>

</div>

</body>

</html>
